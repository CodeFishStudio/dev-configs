---
description: React component rules
globs: *.tsx,*.ts,*.js,*.jsx
alwaysApply: false
---

# React Component Rules

## File Structure

### Global Components

- Components that are used in more than one context (i.e., globally) must be placed in `src/components`
- Each global component must have its own directory named `ComponentName` (PascalCase)
- Directory structure:
    ```
    src/components/ComponentName/
      ├── index.ts
      └── ComponentName.tsx
    ```
- `index.ts` contains just one line: `export * from './ComponentName';`
- `ComponentName.tsx` contains the actual component definition
- Component files must use PascalCase (e.g., `Button.tsx`, `UserProfile.tsx`)

**Example:**

```
src/components/Button/
  ├── index.ts          (contains: export * from './Button';)
  └── Button.tsx         (contains: export const Button = ...)
```

### Sub-Components

- Components that are sub-components of another component should be placed in the parent component's `components` directory
- Sub-components do not need their own folder or `index.ts` file - they are just `.tsx` files directly
- Directory structure:
    ```
    src/components/ParentComponent/
      ├── index.ts
      ├── ParentComponent.tsx
      └── components/
          └── SubComponentA.tsx
          └── SubComponentB.tsx
    ```

**Example:**

```
src/components/UserProfile/
  ├── index.ts                    (contains: export * from './UserProfile';)
  ├── UserProfile.tsx             (contains: export const UserProfile = ...)
  └── components/
      ├── UserAvatar.tsx          (contains: export const UserAvatar = ...)
      └── UserStats.tsx           (contains: export const UserStats = ...)
```

## Component Structure

For React components, the order of a file should be

1. Imports
2. Type declarations
3. Constants (if applicable)
4. Internal helper functions (if applicable)
5. Component definition
    - Imported hooks
    - State
    - Derived state
    - Callbacks
    - useMemo memoised components
    - Effects
    - Render

**Important:** Always follow this exact order to maintain consistency across the codebase.

## Props

- Never use React.forwardRef. React 19 now supports passing a ref as a prop.
- Never destructure component props within the function parameter. Always accept
  `props` as a single argument and destructure within the function body.
- Add an empty line underneath the props destructuring line.
- Must use TypeScript interfaces for props
- Must document complex props with comments
- Must use meaningful prop names
- Must provide default values when appropriate

**Example:**

```tsx
// Good: Props destructuring in function body
export const Button = (props: ButtonProps) => {
    const { label, onClick, disabled = false } = props;

    return (
        <button onClick={onClick} disabled={disabled}>
            {label}
        </button>
    );
};

// Bad: Props destructuring in parameters
export const Button = ({ label, onClick, disabled = false }: ButtonProps) => {
    return (
        <button onClick={onClick} disabled={disabled}>
            {label}
        </button>
    );
};
```

## State

- Prefer derived state over separate `useState`. If a value can be computed from
  existing state/props, compute it directly instead of storing it separately.
- Avoid creating separate state for filtered arrays, lookups, or any value that can be derived from existing data.
- Only use `useMemo` for expensive computations.

**Examples:**

```tsx
// Good: Derived state
const UserList = (props: Props) => {
    const { users, searchTerm } = props;
    const filteredUsers = users.filter((user) =>
        user.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    return <div>{/* render filtered users */}</div>;
};

// Bad: Separate state for derived data
const UserList = (props: Props) => {
    const { users, searchTerm } = props;
    const [filteredUsers, setFilteredUsers] = useState([]);

    useEffect(() => {
        setFilteredUsers(
            users.filter((user) => user.name.toLowerCase().includes(searchTerm.toLowerCase()))
        );
    }, [users, searchTerm]);

    return <div>{/* render filtered users */}</div>;
};
```

## Documentation

- Must include JSDoc comments for complex components
- Must keep documentation up to date with changes
- Document component purpose, props, and any side effects

**Example:**

```tsx
// Good: Has interface and JSDoc comments
interface ButtonProps {
    /**
     * Text to display on the button
     */
    label: string;
    /**
     * Optional click handler
     */
    onClick?: () => void;
    /**
     * Whether the button is disabled
     */
    disabled?: boolean;
}

/**
 * Button component for primary actions
 */
export const Button = (props: ButtonProps) => {
    const { label, onClick, disabled = false } = props;

    return (
        <button onClick={onClick} disabled={disabled}>
            {label}
        </button>
    );
};

// Bad: Missing interface and documentation
export const button = ({ onClick, text }) => {
    return <button onClick={onClick}>{text}</button>;
};
```
